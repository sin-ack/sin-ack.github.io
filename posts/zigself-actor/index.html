<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">


<meta name="author" content="sin-ack">



<meta name="description" content="Hi there. I wanted to do a series of deep dives about various parts of ZigSelf in order to give others a more thorough explanation of how everything works, and also as a braindump in order to verify my thinking. The first post I wanted to make is regarding ZigSelf&rsquo;s implementation of the actor model, as it&rsquo;s the feature I believe is one of the most interesting aspects of the language.">




<meta name="keywords" content=" self  blog ">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="The inner workings of ZigSelf&#39;s actor model" />
<meta name="twitter:description" content="Hi there. I wanted to do a series of deep dives about various parts of ZigSelf in order to give others a more thorough explanation of how everything works, and also as a braindump in order to verify my thinking. The first post I wanted to make is regarding ZigSelf&rsquo;s implementation of the actor model, as it&rsquo;s the feature I believe is one of the most interesting aspects of the language." />


<link rel="canonical" href="https://sin-ack.github.io/posts/zigself-actor/">


<link media="screen" rel="stylesheet" href='https://sin-ack.github.io/css/common.css'>
<link media="screen" rel="stylesheet" href='https://sin-ack.github.io/css/content.css'>
<link media="screen" rel="stylesheet" href='https://sin-ack.github.io/css/highlight.css'>



<title>The inner workings of ZigSelf&#39;s actor model - sin-ack&#39;s writings</title>





  <link rel="stylesheet" href='https://sin-ack.github.io/css/single.css'>
</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://sin-ack.github.io/">sin-ack&#39;s writings</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/posts/">Archives</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/index.xml">RSS Feed</a>
    </span>
    
  </nav>
</header>

    <main id="main" class="post">
      
      
      
      <h1>The inner workings of ZigSelf&#39;s actor model</h1>
      
      <div>
        <b>Keywords: </b>
        
        <a class="link" href='https://sin-ack.github.io/tags/self'>#self</a>
        
        <a class="link" href='https://sin-ack.github.io/tags/zigself'>#zigself</a>
        
        <a class="link" href='https://sin-ack.github.io/tags/actor-model'>#actor-model</a>
        
        <a class="link" href='https://sin-ack.github.io/tags/technical'>#technical</a>
        
      </div>
      
      <div class="content">
        <p>Hi there. I wanted to do a series of deep dives about various parts of ZigSelf
in order to give others a more thorough explanation of how everything works, and
also as a braindump in order to verify my thinking. The first post I wanted to
make is regarding ZigSelf&rsquo;s implementation of the actor model, as it&rsquo;s the
feature I believe is one of the most interesting aspects of the language.</p>
<p>The post starts off with a high-level overview and then gets more technical. The
finer details of the scheduler aren&rsquo;t really as important as the concept behind
it, which I&rsquo;ve hopefully made as clear as possible.</p>
<h1 id="background">Background</h1>
<p><a href="https://github.com/sin-ack/zigself">ZigSelf</a> is an implementation of the <a href="https://selflanguage.org/">Self
programming language</a> in <a href="https://ziglang.org">Zig</a>.
It is a pure prototype-based object programming language where the main method
of executing code is by sending a message to objects. The virtual machine part
is written in Zig while the standard library is written in ZigSelf code.</p>
<p>Early in 2022, I was looking at ways to get a concurrency model in ZigSelf. I&rsquo;m
a big fan of structured concurrency, and while the original Self did have its
own concurrency model, it was a completely unprotected system - Self processes
are preemptively multitasked, and there is no protection between the different
processes regarding memory isolation, which meant a fallback to traditional
locking-based multitasking. I felt that we could do better, as I already had a
managed VM that is able to intercept each object access. While I was looking
into how other programming languages did this, I came across Erlang, and it felt
almost perfect.</p>
<h1 id="how-erlang-does-it">How Erlang Does It</h1>
<p><a href="https://www.erlang.org/">Erlang</a> is a functional programming language designed
to be highly concurrent. The whole system runs on what it calls the <em>actor
model</em>, where many isolated processes concurrently execute and communicate by
message sending. There are two important points to the design here:</p>
<ol>
<li>All Erlang values are immutable (which kind of comes with the functional
territory). This makes it rather cheap to send messages to other processes,
because there is no copying involved beyond compiler optimizations; neither
the sender and receiver can change the object anyway.</li>
<li>Erlang code is written as modules, compiled ahead of time and then run later.
This is important, because the standard functions one uses cannot change
while the program is running (beyond code replacement, but that&rsquo;s rare),
which also removes any worries of someone messing around with the functions
being used.</li>
</ol>
<p>Both of these points make Erlang a really good candidate for the actor model.
They also make ZigSelf a really bad candidate for it.</p>
<h2 id="zigself-is-a-bad-language-for-the-actor-model">ZigSelf is a bad language for the actor model</h2>
<p>The main issue stems from those two points I touched upon. The fact that ZigSelf
is an object oriented programming language, and the fact that it is intended to
be used as a live system and not a &ldquo;compile and deploy&rdquo; type of system means
that actors now have many more hazards that have to be avoided. Let&rsquo;s revisit
those two points:</p>
<ol>
<li>In ZigSelf, objects can have assignable slots which can be modified at will.
This means that sending an object as a message must now copy at least the
writable parts of the object graph, because both the sender and receiver can
now affect each other.</li>
<li>I intend for ZigSelf to be used as a fully live visual programming
environment. Once one introduces the actor model to this equation, all bets
are off for code that needs to access well-known things; the global object
hierarchy can be changed at any time, and all running actors have to cope
with this (this is not a bug &ndash; everything in the system should be
modifiable!).</li>
</ol>
<h2 id="why-i-think-zigself-should-have-the-actor-model">Why I think ZigSelf should have the actor model</h2>
<p>Even though these issues made it look like the actor model was very wrong for
ZigSelf, I was still adamant that it was <em>the one</em>. I had several reasons:</p>
<ol>
<li>In ZigSelf, message passing is the main &ldquo;calling convention&rdquo; - objects
respond to messages sent to them, similar to languages like Smalltalk or
Ruby. The actor model works in almost exactly the same way, except the
responses are asynchronous and disconnected.</li>
<li>In Erlang, processes are isolated bits of running code with their own memory.
Turns out objects in ZigSelf are basically the same thing (<a href="https://stackoverflow.com/a/11421598">objects are poor
man&rsquo;s closures</a>)! So if we use an
object as our <em>actor context</em> and send a message to that object, we get
something akin to an Erlang process.</li>
<li>While the original Self programming environment&rsquo;s model was much closer in
effect to OS threads than something like the actor model, it still was a
process-based model, telling me that if the right balance could be found,
this model is feasible.</li>
</ol>
<p>So, how can we make the actor model work with ZigSelf? We&rsquo;re going to have to
tackle the various problems that we&rsquo;ve talked about so far.</p>
<h1 id="glossary">Glossary</h1>
<p>Let&rsquo;s start with some terminology, because the explanation below can get verbose
without some terms. Feel free to skip this part and reference it whenever an
unknown term is used.</p>
<ul>
<li><strong>Actor.</strong> An actor is a single-threaded piece of code that can execute
concurrently with other actors.</li>
<li><strong>Actor object.</strong> The actor object is the representation of a single actor
within the object heap.</li>
<li><strong>Actor context.</strong> The actor context is the object that is returned in
response to the spawn message. The actor context can be used to store the
state of an actor.</li>
<li><strong>Actor mode.</strong> In ZigSelf, <em>actor mode</em> is entered once the <code>_Genesis:</code>
message is sent to an object. This creates the <em>genesis actor</em>, which acts as
the scheduler for regular actors.</li>
<li><strong>Actor spawner.</strong> The process that spawned the new actor via <code>_ActorSpawn:</code>.
Keep in mind that <code>_Genesis:</code> also spawns an actor but is considered special.</li>
<li><strong>Global actor.</strong> The global actor is the one that code that&rsquo;s not in actor
mode executes in. The global actor basically just behaves like a
single-threaded language runtime such as JavaScript.</li>
<li><strong>Genesis actor.</strong> The genesis actor is the only special actor in actor mode.
It is responsible for scheduling actors and handling the various states that
an actor can enter.</li>
<li><strong>Regular actor.</strong> A regular actor is one that runs user code. It is usually
application code or the programming environment, and works like an individual
operating system process. Regular actors are spawned by sending the
<code>_ActorSpawn:</code> message.</li>
<li><strong>Spawn message.</strong> The spawn message is the message that is sent to an object
in order to obtain a new actor context.</li>
<li><strong>Entrypoint message.</strong> The entrypoint message is the message sent to the
actor context object in order to make it start executing. It is the &ldquo;main
function&rdquo; of the actor (and is named <code>main</code> in the ZigSelf implementation by
default, in fact).</li>
<li><strong>Blessing.</strong> Blessing is an operation performed on an object graph in order
to make copy its writable parts for a new actor. This is used during spawning
and actor messages. Blessing does not copy globally reachable objects.</li>
<li><strong>Globally reachable object.</strong> Globally reachable objects are any objects that
can be reached through the lobby (the root object of ZigSelf). Globally
reachable objects are read-only during actor mode.</li>
<li><strong>Primitive.</strong> A primitive is a message that is defined in the VM. They are
always prefixed with an underscore (which normal methods cannot be prefixed
by). They are similar to &ldquo;built-ins&rdquo; in other programming languages.</li>
<li><strong>Receiver.</strong> Each message has a <em>receiver</em>, which is the object that message
lookup happens on. Within a method activation, <code>self</code> refers to the receiver
of the current activation. Other languages either call this object <code>self</code> or
<code>this</code>. For instance, in the message send <code>object foo: 1 Bar: 2.</code>, the message
<code>foo:Bar:</code> is sent to the receiver <code>object</code>, with the arguments <code>1</code> and <code>2</code>.</li>
</ul>
<h1 id="the-anatomy-of-an-actor">The Anatomy of an Actor</h1>
<p>Before we talk about how ZigSelf implements the actor model, it is important
that I give some information about what an actor looks like in ZigSelf.</p>
<p>The most important parts of an actor is its stacks and its mailbox. There are
various stacks in use by each actor:</p>
<ul>
<li>The activation stack, which is used like a regular call stack in other
programming languages.</li>
<li>The slot stack, which is used while building objects via literals.</li>
<li>The argument stack, which is used for arguments while sending messages.</li>
<li>The saved register stack, which is used for saving registers during calls.</li>
</ul>
<p>Normally, all of these would be within the same stack, but I found it to be much
nicer to keep them in separate stacks. Additionally, because the stacks are
separate, this makes it much easier to do a precise scan on them during a
garbage collection cycle, and also to do it faster (because items of the same
kind are together, which works better with cache lines).</p>
<p>The mailbox of an actor stores the messages that have been sent to an actor
since its last run. When an actor is resumed, it first answers all messages sent
to it before resuming from its last waiting condition.</p>
<p>In addition to the above, actors also store a reference to their actor context
in order to keep it alive, the <em>yield reason</em> of the actor (if it&rsquo;s suspended),
the file descriptor the actor is currently blocked on (if any), and various
other small bits.</p>
<h1 id="entering-actor-mode">Entering Actor Mode</h1>
<p>In order to enter actor mode, one must first enter the <em>genesis actor</em>. This is
done by using the <code>_Genesis:</code> primitive. This primitive takes the name of a
message, <em>blesses</em> the current object and sends the message to the new object.</p>
<p>The genesis actor acts as a <em>scheduler</em> for the other actors; when a new actor
is spawned, the genesis actor gets the actor object, and is responsible for
resuming each actor. In addition, the genesis actor also has access to which
file descriptor each actor is blocked on, and can use this information to wait
until a specific event happens, behaving similarly to an event loop. The low
level details of actor states and how the standard library scheduler works is
detailed in <a href="#actor-scheduling-in-userspace">Actor Scheduling in Userspace</a>.</p>
<p>Once the main activation of the genesis actor is exited, the VM exits actor mode
and control returns to the global actor. The ZigSelf VM can enter and exit actor
mode as many times as the user wishes, but there can only be one genesis actor
at a time.</p>
<h1 id="creating-a-new-regular-actor">Creating a New Regular Actor</h1>
<p>In Erlang, in order to create a new process, one calls the <code>spawn</code> family of
functions (which has different arities depending on what the process creator
wants to happen). This creates the process and then returns the <em>process ID</em>
(PID), which the process creator can then use in order to send messages, manage
and otherwise communicate with the process.</p>
<p>ZigSelf works similarly to this. There is a primitive called <code>_ActorSpawn:</code>
which allows an actor to send a message to an object in order to spawn a new
actor. This primitive runs through the following steps:</p>
<ol>
<li>Send the message with the given name to the receiver (this is the &ldquo;spawn
message&rdquo;). This message is executed to completion within the actor spawner,
and suspension of the current actor is not permitted during this time. The
object that&rsquo;s returned in response to this message becomes the actor context.
In addition, the spawn message is responsible for calling
<code>_ActorSetEntrypoint:</code>, which tells the <code>_ActorSpawn:</code> primitive what message
to send as the entrypoint message for this actor.</li>
<li>The new actor is created.</li>
<li>The returned object is &ldquo;blessed&rdquo; to be owned by the newly created actor. The
details of why this is necessary is given in <a href="#actor-memory-ownership">Actor Memory
Ownership</a>.</li>
<li>The entrypoint message that was set during the spawn message is sent to the
new actor&rsquo;s context.</li>
</ol>
<p>Once all of these steps are taken, the new actor object is returned. However,
how it is returned depends on the actor spawner:</p>
<ol>
<li>If the actor spawner is the genesis actor, the <code>Actor</code> object is the
response.</li>
<li>If the actor spawner is a regular actor, then there are two responses: the
actor spawner gets a <code>ActorProxy</code> which it can use to send messages, and is
immediately suspended and the <code>Actor</code> object is the response of the actor
spawner&rsquo;s execution for the genesis actor. The genesis actor can then manage
the <code>Actor</code> object as needed and resume the actor spawner.</li>
</ol>
<p>(Note: ZigSelf currently doesn&rsquo;t allow one to send arguments in an actor spawn
message.)</p>
<h1 id="memory-isolation">Memory Isolation</h1>
<p>In Erlang, all process memory is isolated. This means that a process cannot
access memory owned by another process. This completely solves the shared memory
synchronization problem in conventional multi-threading. However, solving this
problem comes with its own peculiarities, namely the fact that the language&rsquo;s
model has to change significantly to adapt to this (which is why Erlang data
structures are immutable).</p>
<p>ZigSelf is an object programming language and mutating objects by sending them
messages is the natural way of using it. As such, one must take extra care when
designing a memory isolation system. ZigSelf employs a few different methods to
ensure that memory is properly isolated between actors.</p>
<h2 id="actor-memory-ownership">Actor memory ownership</h2>
<p>Earlier I had mentioned that each actor owns its memory and there is no memory
sharing allowed between actors. This is ensured by marking every newly-created
object with the actor that created it. Reading other actors&rsquo; memory is prevented
by simply not making it possible to reference that memory in the first place;
getting one&rsquo;s hands on an object owned by another actor is an immediate VM crash
since that would mean that a VM invariant is broken.</p>
<p>However, there is one small wrinkle in this model: spawning of new actors. In
<a href="#creating-a-new-regular-actor">Creating a New Regular Actor</a>, I mentioned that
the object that&rsquo;s returned as the response of the spawn message is &ldquo;blessed&rdquo;.
But why is this necessary?</p>
<p>The problem here is a variation of the chicken and egg problem: In order for the
new actor to be able to clone memory, it needs to be able to somehow reach the
object it wants to clone. In ZigSelf, nothing is actually truly &ldquo;global&rdquo;: one
reaches the global objects by going up the lookup chain until the lobby (the
root object) is reached, after which one sends a series of messages to the lobby
in order to find the well-known object (for example, <code>std vector</code> is just <code>std</code>
being sent to the current activation object, and <code>vector</code> being sent to the
response of that message).</p>
<p>In the last sentence I said &ldquo;current activation object&rdquo;. That is what&rsquo;s referred
to as <code>self</code> within a method. The problem becomes obvious after this: if the
actor doesn&rsquo;t have any memory of its own yet, it can&rsquo;t have anything to call
<code>self</code>, and so running any non-trivial code at all would be an instant crash.
This is the reason the spawn message is executed within the actor spawner, and
it is also why the &ldquo;blessing&rdquo; step is needed &ndash; once the new actor context is
returned from the spawn message, it is then made to belong to the new actor, and
the new actor can now execute code through its own memory.</p>
<h2 id="read-only-global-object-hierarchy">Read-only global object hierarchy</h2>
<p>Of course, the aforementioned memory ownership works fine for objects owned by
the actor itself, but one can&rsquo;t really write useful code without being able to
reuse code from places like the standard library (you could definitely stuff all
your required definitions within your actor context, but nobody actually does
that, right? :^). This is where we hit another problem: ZigSelf doesn&rsquo;t have a
module system in the traditional sense where code is physically separated. This
is not a bug - it is actually one of the great features of the snapshot-based
virtual machine model. It allows for one to pack everything the program needs
within a single file and carry it elsewhere, and need only the virtual machine
to handle the non-portable parts.</p>
<p>However, this also means that all actors have to share the same global object
hierarchy. This means (<em>gasp</em>) shared memory! So how can ZigSelf solve this
problem while keeping things ergonomic?</p>
<p>From my observations working with ZigSelf for the past year, the global object
hierarchy is seldom modified during normal runtime (to the point where it could
be considered completely static). Then it hit me - why not just make it static?
We could freeze the global hierarchy, at least during normal actor operation,
and stop the world during those few moments when someone actually modifies the
global object hierarchy.</p>
<p>This idea gives us the best of both worlds: Keep the system fully live and
malleable, and make it possible for actors to work without significant slowdowns
caused by locking for each global access.</p>
<p>Here&rsquo;s how it works: In addition to the owning actor for each object, the most
significant bit of each object&rsquo;s header word contains a &ldquo;globally reachable&rdquo;
bit. This bit is poisonous; objects that are made reachable through a globally
reachable object via any means become marked as globally reachable themselves.
Initially, only the base object traits and the root object are marked as
&ldquo;globally reachable&rdquo;, and it propagates as the standard library is built during
world creation.</p>
<p>While actor mode is off, globally reachable objects can be modified freely. Once
actor mode is turned on however, all globally reachable objects are put into
read-only mode. There is currently no way to modify the global hierarchy in
actor mode, but I intend to create a primitive that allows this soon.</p>
<p>The addition of the globally reachable bit actually aids actor memory isolation.
Because globally reachable objects are read-only during regular actor operation,
there is no need to copy them; they behave similarly to Erlang&rsquo;s immutable data
structures in this sense. Therefore, the blessing operation skips parts of the
object graph that are globally reachable, which makes things like blessing a
standard library data structure as simple as deep copying the data structure&rsquo;s
contents, without bringing the whole standard library with it.</p>
<h2 id="actor-message-copying">Actor message copying</h2>
<p>At the start, I mentioned that because of ZigSelf&rsquo;s mutable nature, objects sent
as part of actor messages have to be copied. This is done by just combining the
previous two points: all non-globally reachable objects that are part of a sent
message&rsquo;s object graph are copied and a reference is stored to the copy in the
recipient&rsquo;s mailbox.</p>
<p>When an actor is resumed, it first looks into the mailbox and executes any
messages that it has received. Any invalid messages are handled during the
initial send to the ActorProxy object, and a reference to the method object is
stored on the mailbox, so there is no possibility of a &ldquo;delayed&rdquo; method lookup
error. All messages in the mailbox are executed before control returns to the
point where the actor had previously been paused.</p>
<p>This actually works surprisingly well in practice, because most messages that
are sent include standard things like integers, vectors and byte arrays
(strings).</p>
<h1 id="actor-scheduling-in-userspace">Actor Scheduling in Userspace</h1>
<p>When I was looking into how other programming languages handled their
concurrency, I noticed a distinct separation between languages that delegate
scheduling to userspace and languages that handle scheduling directly within the
virtual machine. For example, when Python introduced asynchronous support in 3.5
it decided that handling of coroutines should be delegated to an event loop
implementation in Python code. I found that to be much more closely aligned with
my own goals, because it has spawned great projects like
<a href="https://github.com/python-trio/trio">Trio</a> which provide very cool improvements
over Python&rsquo;s default event loop implementation. Comparing this with languages
like Javascript where the virtual machine defines how the event loop is to be
executed without allowing any introspection or replacement made the choice to
put the scheduler in userspace obvious.</p>
<p>In ZigSelf, there are various primitives provided by the virtual machine that
allows one to control the running state of an actor and also to get various bits
of information from it. These primitives will be explored shortly, but first
let&rsquo;s take a look at how the scheduler in ZigSelf&rsquo;s standard library currently
executes processes at a high level.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-smalltalk" data-lang="smalltalk"><span class="line"><span class="cl">(<span class="err">|</span>
</span></span><span class="line"><span class="cl">    <span class="nv">parent</span><span class="nf">*</span> <span class="err">=</span> <span class="nv">std</span> <span class="nf">traits</span> <span class="nf">clonable</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">readyQueue</span> <span class="nf">=</span> <span class="nv">std</span> <span class="nf">vector</span> <span class="nf">copy</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    <span class="nv">blockedQueue</span> <span class="nf">=</span> <span class="nv">std</span> <span class="nf">vector</span> <span class="nf">copy</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c">&#34;Given a yielded actor, execute the correct action based on its
</span></span></span><span class="line"><span class="cl"><span class="c">     yield reason.&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">handleSuspensionOf:</span> <span class="nv">actor</span> <span class="nf">WithResult:</span> <span class="nv">result</span> <span class="err">=</span> (<span class="err">|</span>
</span></span><span class="line"><span class="cl">        <span class="nv">reason</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        <span class="nv">yieldReason</span> <span class="nf">=</span> <span class="nv">std</span> <span class="nf">actor</span> <span class="nf">yieldReason</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    <span class="err">|</span>
</span></span><span class="line"><span class="cl">        <span class="nf">reason:</span> <span class="nv">actor</span> <span class="o">_</span><span class="err">ActorYieldReason</span>.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nv">reason</span> <span class="nf">=</span> <span class="nv">yieldReason</span> <span class="nf">dead</span> <span class="nb">ifTrue:</span> [
</span></span><span class="line"><span class="cl">            <span class="c">&#34;There&#39;s nothing to do since the actor has died.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="o">^</span> <span class="bp">nil</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        ]<span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nv">reason</span> <span class="nf">=</span> <span class="nv">yieldReason</span> <span class="nf">yielded</span> <span class="nb">ifTrue:</span> [
</span></span><span class="line"><span class="cl">            <span class="c">&#34;The actor has yielded on its own and is ready to be
</span></span></span><span class="line"><span class="cl"><span class="c">             executed again.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">readyQueue</span> <span class="nf">append:</span> <span class="nv">actor</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">            <span class="o">^</span> <span class="bp">nil</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        ]<span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nv">reason</span> <span class="nf">=</span> <span class="nv">yieldReason</span> <span class="nf">actorSpawned</span> <span class="nb">ifTrue:</span> [
</span></span><span class="line"><span class="cl">            <span class="c">&#34;This actor spawned another actor (which is now in result).
</span></span></span><span class="line"><span class="cl"><span class="c">             Put this actor and the new actor in the ready queue.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">readyQueue</span> <span class="nf">append:</span> <span class="nv">result</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">            <span class="nv">readyQueue</span> <span class="nf">append:</span> <span class="nv">actor</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">            <span class="o">^</span> <span class="bp">nil</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        ]<span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nv">reason</span> <span class="nf">=</span> <span class="nv">yieldReason</span> <span class="nf">blocked</span> <span class="nb">ifTrue:</span> [
</span></span><span class="line"><span class="cl">            <span class="c">&#34;The actor performed a blocking operation. Put it in the
</span></span></span><span class="line"><span class="cl"><span class="c">             blocked queue. blockedActor is a helper object that
</span></span></span><span class="line"><span class="cl"><span class="c">             stores the FD the actor is blocked on by sending the
</span></span></span><span class="line"><span class="cl"><span class="c">             actor it&#39;s given the _ActorBlockedFD primitive.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">blockedQueue</span> <span class="nf">append:</span> <span class="nv">blockedActor</span> <span class="nf">copyActor:</span> <span class="nv">actor</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">            <span class="o">^</span> <span class="bp">nil</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        ]<span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nv">reason</span> <span class="nf">=</span> <span class="nv">yieldReason</span> <span class="nf">runtimeError</span> <span class="nb">ifTrue:</span> [
</span></span><span class="line"><span class="cl">            <span class="c">&#34;The actor received a runtime error.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nf">handleRuntimeErrorFor:</span> <span class="nv">actor</span>.
</span></span><span class="line"><span class="cl">            <span class="o">^</span> <span class="bp">nil</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        ]<span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="err">raiseError:</span> <span class="s">&#39;Actor yielded for unknown reason&#39;</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    )<span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nv">schedule</span> <span class="nf">=</span> (
</span></span><span class="line"><span class="cl">        <span class="c">&#34;Start the first actor somehow. This is done in the actual
</span></span></span><span class="line"><span class="cl"><span class="c">         implementation via std scheduler startBySending:To:.&#34;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">readyQueue</span> <span class="nf">append:</span> <span class="nv">spawnTheFirstActorSomehow</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        [<span class="o">|</span> <span class="err">:</span><span class="nv">break</span><span class="p">.</span> <span class="err">:</span><span class="nv">continue</span> <span class="nf">|</span>
</span></span><span class="line"><span class="cl">            <span class="c">&#34;Check if there are any ready processes to execute.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">readyQueue</span> <span class="nf">isEmpty</span> <span class="nf">not</span> <span class="nb">ifTrue:</span> [<span class="o">|</span> <span class="nv">firstReadyActor</span><span class="p">.</span> <span class="nv">result</span><span class="p">.</span> <span class="err">|</span>
</span></span><span class="line"><span class="cl">                <span class="nf">firstReadyActor:</span> <span class="nv">readyQueue</span> <span class="nv">shift</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">                <span class="c">&#34;Resume the actor from where it left off.&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="nf">result:</span> <span class="nv">firstReadyActor</span> <span class="o">_</span><span class="err">ActorResume</span>.
</span></span><span class="line"><span class="cl">                <span class="c">&#34;Once we get here, the actor has executed and
</span></span></span><span class="line"><span class="cl"><span class="c">                 suspended again. Figure out why the actor was
</span></span></span><span class="line"><span class="cl"><span class="c">                 suspended and add it to the correct queue.&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="nf">handleSuspensionOf:</span> <span class="nv">firstReadyActor</span> <span class="nf">WithResult:</span> <span class="nv">result</span>.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="c">&#34;Continue with scheduling.&#34;</span>
</span></span><span class="line"><span class="cl">                <span class="nv">continue</span> <span class="nf">value</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">            ]<span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c">&#34;There were no ready processes. If there are no blocked
</span></span></span><span class="line"><span class="cl"><span class="c">             processes either, then everything has successfully executed
</span></span></span><span class="line"><span class="cl"><span class="c">             and we can exit the scheduler.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">blockedQueue</span> <span class="nf">isEmpty</span> <span class="nb">ifTrue:</span> <span class="nv">break</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">            <span class="c">&#34;There were blocked processes. Let&#39;s wait until at least one
</span></span></span><span class="line"><span class="cl"><span class="c">             of them become unblocked.&#34;</span>
</span></span><span class="line"><span class="cl">            <span class="nv">waitForBlockedProcesses</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">        ] <span class="nf">loopBreakContinue</span><span class="p">.</span>
</span></span><span class="line"><span class="cl">    )<span class="p">.</span>
</span></span><span class="line"><span class="cl"><span class="err">|</span>) <span class="o">_</span><span class="err">Genesis:</span> <span class="s">&#39;schedule&#39;</span><span class="p">.</span>
</span></span></code></pre></div><p>I&rsquo;m omitting the implementation of various functions here, but this is the
overall structure of the ZigSelf scheduler as of writing. The most important
parts here are:</p>
<ul>
<li><code>_ActorSpawn:</code> - This is how new actors are created. The initial actor is
created by giving the scheduler an object to send a message to, and the rest
is handled by the scheduler as can be seen above.</li>
<li><code>_ActorResume</code> - This is the most important part of the actor model in
ZigSelf. It is essentially a <a href="https://en.wikipedia.org/wiki/Context_switch">context
switch</a> - it switches from the
currently executing actor to another one and resumes it from where it had
previously left off.</li>
<li><code>_ActorYieldReason</code> - An actor may have paused for various reasons, and this
is how the scheduler learns why an actor has stopped. This information can
then be used in order to guide what the scheduler should do with the actor, as
can be seen above.</li>
<li><code>_ActorBlockedFD</code> - The file descriptor that the actor is blocked on. Certain
operations such as reading will block the actor instead of the entire virtual
machine when actor mode is enabled, and the file descriptor that the actor
tried to read from will be stored in order to give it to the scheduler.</li>
</ul>
<p>These four primitives allow us to implement a scheduler in userspace. The choice
to expose these attributes was deliberate, as explained above.</p>
<h1 id="an-actors-lifecycle">An Actor&rsquo;s Lifecycle</h1>
<p>In the previous section we looked at how the scheduler is implemented in code,
but I think the best way to explore a ZigSelf actor&rsquo;s lifecycle is with a graph.
Below, you can see a state diagram for an actor.</p>
<figure><img src="/images/zigself-actor/state-diagram.png"
         alt="State diagram
for the lifecycle of an actor."/><figcaption>
            <p>State diagram
for the lifecycle of an actor.</p>
        </figcaption>
</figure>

<p>There are currently 5 reasons that a regular actor can yield:</p>
<ul>
<li><strong>Yielded.</strong> This is the simplest reason. The actor can send the <code>_ActorYield</code>
message at any time in order to pause its execution. This is useful for things
like servers where the actor can yield itself after handling incoming messages
in order to give other actors a chance to run.</li>
<li><strong>Blocked.</strong> The actor tried to perform an operation that would block and is
now suspended. The scheduler can resume the actor once the operation no longer
blocks. Keep in mind that this yield reason causes the last instruction that
was executed to be re-executed once the actor is resumed (blocking primitives
are atomic, so they can be retried if they caused a block).</li>
<li><strong>Runtime error.</strong> The actor received a runtime error due to a programming
error. Runtime errors are different from regular errors and cannot be caught.
This also borrows from Erlang&rsquo;s &ldquo;let it fail&rdquo; style.</li>
<li><strong>Dead.</strong> The actor has successfully executed all of its code and has exited
successfully. There is nothing else to be done.</li>
<li><strong>Actor spawned.</strong> The actor sent the <code>_ActorSpawn:</code> message to an object and
successfully spawned another actor. As explained in <a href="#creating-a-new-regular-actor">Creating a New Regular
Actor</a>, this pauses the spawning actor and
returns the actor object to the genesis actor. The spawning actor can then be
resumed normally.</li>
</ul>
<p>The diagram above explains what the current scheduler does for each action.</p>
<h1 id="actor-messages">Actor Messages</h1>
<p>A single actor by itself isn&rsquo;t very useful, because an actor can only represent
a single concurrent computation. In order to take advantage of the full
potential of the actor model, we need to have multiple actors, and those actors
need to be able to communicate with each other. This is where message passing
comes in.</p>
<p>In ZigSelf, sending a message to another actor is extremely simple: You just
need the actor proxy object for that actor (which is given to you via
<code>_ActorSpawn:</code>), and you send a message to that actor proxy object. All actor
messages are currently asynchronous.</p>
<p>When a message is sent to the actor proxy, the message is looked up on the
target actor&rsquo;s context. If the result of the lookup is not a method, then it&rsquo;s
simply discarded. This allows for stubbing out some messages. Otherwise, a
reference to the method object and all the passed arguments are saved into the
actor&rsquo;s mailbox so that it can handle the messages the next time it&rsquo;s resumed.</p>
<h1 id="unanswered-questions">Unanswered Questions</h1>
<p>The eventual goal of ZigSelf&rsquo;s actor model is to schedule actors on multiple
threads at once, which is possible due to the model itself preventing shared
memory as much as possible. However, there are still various open questions
that have to be answered before this can be fully realized.</p>
<p>For example, if we execute multiple actors at once, how does the scheduler run?
In the current model, the scheduler is just another actor and takes control when
the currently running actor suspends. However, once we are scheduling multiple
actors at the same time, how can the scheduler handle all of them at once? For
this, I see a couple solutions:</p>
<ol>
<li>Adding onto the genesis actor&rsquo;s special properties, make it execute on all
cores at once. This means a return to the unsafe concurrency model but only
for the scheduler.</li>
<li>Use an extra thread just for the genesis actor. This is based on the
hypothesis that the scheduler will have less to do than all the actors and so
will be able to handle the load, but comes with the problem of having to
manage both unblocking blocked actors and scheduling ready ones at the same
time. Additionally, since the scheduler will now have control even when
actors are running, receiving new actors as a response to <code>_ActorSpawn:</code>s may
pose a problem.</li>
</ol>
<p>More importantly, there is the issue of concurrent garbage collection. ZigSelf&rsquo;s
object heap implementation currently uses no locks, which works fine because
there is only one thread of execution. However, once multiple threads are
involved, this poses a great problem: because almost all operations will produce
new objects, if the current model is kept, a lot of performance will be
sacrificed by locking for every object creation. The simplest solution here
would be completely separating the heaps for each actor, and this seems to be
the approach employed by Erlang itself; however this might be prohibitively
expensive, so a compromise could be to separate just the eden (the area where
new objects get created) at a reasonable level of granularity (per thread? per
actor?) and then lock only when a tenure from an eden to the shared eden space
happens.</p>
<p>Furthermore, some things such as file descriptors are process-wide and must be
shared. Currently, ZigSelf wraps such resources with a <code>Managed</code> object so
sharing can be managed here. Perhaps an implementation of move semantics is
possible, where sending an actor a message with a <code>Managed</code> object &ldquo;moves&rdquo; that
<code>Managed</code> object to the receiving actor.</p>
<p>Finally, there are some cases where sharing memory is either necessary or
greatly beneficial to performance, such as when parallel operations are
performed over a large block of memory (such as parallel rendering). I don&rsquo;t
have ideas on how to handle this just yet, but I think we could allow
compromises here through some other mechanism.</p>
<h1 id="future-goals">Future Goals</h1>
<p>As of now, the actor model is almost fully integrated into ZigSelf. However,
there are many goals I want to accomplish before it&rsquo;s ready for prime-time.</p>
<p>Firstly, there are many low-hanging fruit regarding performance in actor message
sending, such as copy-on-write. The current message sending implementation is
&ldquo;the simplest thing that could possibly work&rdquo;, and I intend to do various
optimizations in this area to minimize the impact of message sending.</p>
<p>Moreover, the mailbox is currently implemented as a linked list because I
believed at the time that it was possible that the mailbox wouldn&rsquo;t be emptied
before receiving messages again. In practice this doesn&rsquo;t seem to be the case,
and the mailbox can be implemented as a simple vector, greatly reducing the
required allocations to maintain it (and therefore reduce the overhead).</p>
<p>And finally, I also want to reduce the disconnect between a message and its
response. In Erlang, messages are distinguished by atoms sent as the first
element of the message, and the response is handled in a similar way. I believe
that we can have better abstractions. In particular, I want to have a
promise-like system where one can wait on the response of an asynchronous actor
message without expecting a specific string or atom. Alternatively, some
messages could be made synchronous, where the sending actor suspends itself and
runs the other actor in its place with just that message before regaining
control once the response is calculated. This could be a good alternative to
reduce latency for some messages where the execution time is expected to be
small.</p>
<h1 id="conclusion">Conclusion</h1>
<p>In this post I went over the state of the actor model implementation in ZigSelf
as of November 2022. There are still many challenges and unanswered questions
before I can fully realize my dream of an actor-based object programming system
that runs on multiple cores, but if it were so easy it wouldn&rsquo;t be fun :^) I
would recommend keeping an eye on the <a href="https://github.com/sin-ack/zigself/issues">open
issues</a> to track the progress of the
actor model.</p>
<p>I know I said that I would do monthly updates regarding ZigSelf, however I
unfortunately didn&rsquo;t have time to work on ZigSelf during the past few months so
there was nothing to write about. However, December seems promising. Stay tuned!</p>
<p>Oh, also: ZigSelf now has a <a href="https://discord.gg/HJ62kw6yvn">Discord server</a>,
where you can talk to me and others about the language, and ask any
questions/make suggestions about this post. Hoping to see you over there.</p>
<h1 id="aside-why-the-name-genesis">Aside: Why the name &ldquo;genesis&rdquo;?</h1>
<p>People have asked me why I chose the name &ldquo;genesis&rdquo; for the primitive that lets
one enter actor mode. The name is an homage to the original Self programming
environment, which calls the place where new objects are created &ldquo;eden&rdquo; (a name
which ZigSelf also uses). The name of the &ldquo;blessing&rdquo; operation follows a similar
theme. :^)</p>

      </div>
      <div class="paginator">
        
        <a class="link" href="https://sin-ack.github.io/posts/sycl-talk-20221007/">← prev</a>
        
        
        <a></a>
        
      </div>
      <div class="comment">
        
      </div>
      
    </main>
    <footer id="footer">
  <div>
    <span>© 2019</span> - <span>2022</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
    <span> + </span>
    <a class="link" href="https://github.com/sin-ack/hugo-theme-texify">some changes</a>
  </div>

  <div class="footnote">
    <span></span>
  </div>
</footer>

  </div>
  

<link media="screen" rel="stylesheet" href="https://sin-ack.github.io/css/custom.css" />





</body>

</html>
